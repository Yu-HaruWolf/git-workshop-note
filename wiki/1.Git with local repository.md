# What is Git?
Gitは、プログラムのソースコードなどの変更履歴を記録・追跡するための分散型のバージョン管理システムです。Linux カーネルのような大規模なプロジェクトでも、スピードとデータサイズの両方の面で効率的に管理することができるように、2005年に開発されました。分散型のシステムなので、開発環境がオフラインでもほとんどの機能を利用することができます。また、古いバージョンのファイルを残しておきたい場合にも「file.txt」「新file.txt」のような管理をする必要はありません。
## バージョン管理システムとは？
話をシンプルにするために、まずは分散型という点を無視してお話します。<br>
バージョン管理システムGitのイメージ図です。<br>
<img src="https://raw.githubusercontent.com/Yu-HaruWolf/git-workshop-note/349ec9eda546dcc039cb4c651d051e7cdd9bc817/images/git_branch_image_diagram.png" height="300px" alt="Git branch image diagram"><br>
丸が登録されたファイルの履歴だと思ってください。<br>
この例では、masterの行(ブランチ)に常に公開用のプログラムが含まれており、new-featureのブランチで新機能を開発しています。新機能の開発の途中で生まれたバグを新機能開発と同時並行で開発するために、bug-fixブランチを増やし、更にバグを直すために人手が必要と判断してbug-fix2のブランチを増やしています。バグ修正が終わったら元のブランチに統合し、新機能が完成したら、masterブランチに統合しています。具体的なイメージをしていると、統合の方法がイメージしづらいかもしれませんが、それは後ほど具体的な説明を行うので、今はなぜかきれいにくっついてしまうと思っていて大丈夫です。<br>
また、これらの丸には全て固有のIDが振られており、いつでもその状態に戻って作業することができます。<br>
これがバージョン管理システムのGitのイメージです。
## 分散型とは？
続いて、分散型のイメージを確認しましょう。<br>
<img src="https://raw.githubusercontent.com/Yu-HaruWolf/git-workshop-note/349ec9eda546dcc039cb4c651d051e7cdd9bc817/images/git_collaborate_image_diagram.png" height="300px" alt="Git collaborate image"><br>
先程確認したバージョン管理システムをサーバー上と、開発者それぞれで実行しているイメージです。基本的にはサーバー上で動作しているバージョン管理システムと同期させながら作業を進めていきますが、開発者はそれぞれ手元でバージョン管理システムが動作しているので、常に同期をさせる必要がありません。オンラインになったときに、各開発者がバージョン管理システムを同期させ、統合すれば良いのです。これがオフラインの開発環境下でも作業ができる理由です。こちらも統合がイメージしづらいかもしれませんが、またなぜかきれいにくっついてしまうと思っていて大丈夫です。
# The vocabulary in Git
ここからは実際の単語と動作を見ながら、基本的な流れを確認していきましょう。
## Repository(リポジトリ)
プロジェクトフォルダと言い換えるとわかりやすいかもしれません。バージョン管理をするフォルダそのもののことです。
## Stage(ステージ)
追加・変更したファイルをGitに登録するための準備場所です。コミットをする際は複数ファイルを登録することが多いです。ただ、変更をすべて登録したいわけではないかもしれません。そこでこのステージに追加するステップを挟むことで、任意のファイルの変更情報をコミットできるようになります。
## Commit(コミット)
ステージにあるファイルの変更情報をGitに登録することです。
## Branch(ブランチ)
直訳だと「枝」です。バージョン管理を枝分かれさせたものを指します。
## Merge(マージ)
並列して行っていた変更を1つにまとめることです。基本的には自動でまとめてくれますが、うまくいかないこともあるので、そこは開発者たちで判断していきましょう。
# Let's try Git!
実はこれだけで自分1人の環境であれば最低限Gitが使えるようになっちゃいます。<br>
早速試してみましょう。
## 実行環境について
手元でGitの環境が用意できている方は次のステップに進んで試していきましょう。<br>
もし、手元にGitの環境がなく、用意できる自信がない場合は[Google Cloud Shell](https://shell.cloud.google.com/?show=terminal)を使って試してみましょう。<br>
([Git](https://git-scm.com/)のインストールは難しくないので、ぜひ手元の環境でも使えるようにしましょう！)<br>
[Google Cloud Shell](https://cloud.google.com/shell?hl=ja)はGoogleユーザーであれば、誰でも無料で使うことができます。決済情報の登録も不要です。よく使用される開発環境があらかじめセットアップされた状態になっているので、とりあえず試したい時におすすめです。(しかも半永続の5GBのストレージ付き！)
## Gitの開始
ここでは、「git-lab1」というディレクトリを作成し、Gitリポジトリにして作業します。
```bash
mkdir git-lab1
cd git-lab1
```
ディレクトリを作成したらカレントディレクトリ(現在のディレクトリ)を作成したディレクトリに変更するのをお忘れなく。<br>
このディレクトリでGitを始めるには次のコマンドを実行するだけです。
```bash
git init
```
シンプルですね。選択肢も出てきません。initはinitializeの略で、初期化する際に使用するコマンドでよく出てきます。<br>
これでGitの準備が完了したと言いたいところですが、実は設定が必要な項目があります。コミットする際に、そのコミットが誰によるものなのかを記録しておくのですが、その設定をしておく必要があります。<br>

次のコマンドで名前とメールアドレスを設定しましょう。これらの設定項目は基本的に公開されるものになります。
```bash
git config --local user.name “Your Name”
git config --local user.email “example@example.com”
```
※”(ダブルクオーテーション)も必要です
## ファイルの変更を記録する
設定ができたら、早速作業を始めていきましょう。まずは管理対象のファイルがないと始まりませんね。テキスト形式であればなんでもいいので、とりあえずファイルを作ってみましょう。(バイナリ形式のファイルも管理はできますが、Gitのマージ機能を活かせないのでここでは説明しません。)

※任意のテキストエディタで何かファイルを作ってください。内容は挨拶や自己紹介など好きなものを書いてみましょう。できたら保存して、次のステップに進みましょう。

次のコマンドでgitの状態がどうなっているか確かめましょう。
```bash
git status
```
このようなテキストが表示されましたか？
```
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        main.py

nothing added to commit but untracked files present (use "git add" to track)
```
※今回はmain.pyというファイルを作成しました。<br>
Untracked files(未追跡のファイル)に作成したファイル名が表示されていますか？もし表示されていない場合は、ファイルが正しく作成されているか確認してください。これ以降のこと全てにおいてそうですが、エラー文が出ている場合はGoogle等で検索したり友人に聞いてみてください。

このままだとgitがファイルの変更を追跡してくれないので、gitにこのファイルの追加記録を書き込みましょう。まずは次のコマンドでステージにファイルを追加しましょう。
```bash
git add main.py
```
※main.pyは作成したファイル名で実行してください。これ以降もファイル名が出てきた場合は、ご自身で作成されたファイル名に置き換えて実行してください。

うまく行けば、何も表示されません。改めて、「git status」で状態を確認してみましょう。
```
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   main.py
```
Changes to be committed(コミットされる変更)に作成したファイルが追加されましたね。これがステージに追加された状態です。もし誤って変更記録に記録したくないファイルを追加した場合は、「`git rm –-cached main.py`」 でステージから削除してください。(ファイルは残ります)<br>
ステージに追加できたら、gitに変更記録を記録しましょう。変更記録にはメッセージが必要になります。変更記録の内容を簡潔にまとめたものを指定できると良いでしょう。(メッセージの書き方はおおよそ決まったものがあり、検索すれば出てきますがここでは触れません。プロジェクト、組織単位でルールを決めて、お互いが分かりやすいものを使用すると良いでしょう。)<br>
次のコマンドでgitに変更記録を記録します。<br>
```bash
git commit --message "Create a first file"
```
これで記録すること(commit)ができました！コミットされた内容の概要が表示されます。コミットされた内容を確認してみましょう。<br>
記録された内容を確認するには次のコマンドを実行します。
```bash
git log
```
次のようなものが出力されます。
```
commit fa72bb0cdf946f873668c715932e263f0342458b (HEAD -> master)
Author: Yuki Hirai <32705755+Yu-HaruWolf@users.noreply.github.com>
Date:   Mon Nov 20 01:22:18 2023 +0000

    Create a first file
```
全てのコミットには固有のIDが振られます。後ろについている「HEAD -> master」では、HEADは現在の状態を表し、masterはブランチ名を表しています。あとは、コミットした人の名前とメールアドレス、コミットした日時、コミットメッセージが表示されていますね。これまで入力した内容が正しく表示されていればここまでバッチリです！<br>
(ちなみにコミットで追加されたファイル、内容は何だったかを具体的に確認する方法がありますが、ひと目見ただけでは少しわかりにくいのでコマンド上で確認する方法はここでは触れません。オンラインのGitHub上で確認する方法は後ほど触れます。)

この後のハンズオンのためにも、次のことに挑戦してみましょう！
- 作成し、コミットしたファイルを変更しましょう。
- 変更内容をコミットしましょう。
(実はgit addをしなくても、変更された全てのファイルを一発でコミットする方法があります。ここまで余裕だった方は調べて挑戦してみましょう。)
- コミットできていることを確認しましょう。

## 過去の変更に遡って編集する
コーディングをしていると、時々とんでもない量のエラーと遭遇して直せなくなってしまった時、うまく動いていた時に戻りたい時があるかもしれません。gitならそれができちゃいます。早速やってみましょう。<br>
ここまでの内容をしっかりとやってもらえていれば、既にコミットは2回以上行っているはずです。<br>
現在の状態から過去のコミットに遡るには次のコマンドを実行します。
```bash
git switch --detach fa72bb0cdf946f873668c715932e263f0342458b
```
とんでもなく長いコマンドが出てきましたね。2番目の引数として入っている「fa72bb…(略)」というような文字列を見た覚えはありますか？これはcommitに割り当てられていた固有IDですね。長いので、「git log」からコピペしてしまいましょう。<br>
なお、この時点でコミットしていない変更があると遡ることができません。一時的に退避しておく方法もありますが、後ほど説明するので、ここではコミットで対処しておくことをおすすめします。<br>
switchを実行したら、作成したファイルが過去の状態に戻っているか確認してください。<br>
戻ったら、その状態から編集作業を始めたいところですが、実はこのまま始めると結構危ないんです。今過去の変更に遡ったので、ここから変更を行うと、今まで行ってきた変更とは別の時系列へと進んでいくことになります。この時系列に名前を付けないと、元の時系列に戻ったときに変更を失ってしまう可能性が高いです。(detach-切り離し状態)なので、新しくできる時系列(branch)に名前を付けましょう。コミットメッセージと同様に、branch名にも様々な命名規則があります。こちらもここでは触れないので、ぜひ調べて、プロジェクト・組織単位で揃えてください。<br>
次のコマンドを実行して、branchに名前を付けます。
```bash
git switch --create dev-newMessage
```
実行したら、次のコマンドを実行して、作成したbranchとmaster branchの両方があるかどうか確認しましょう。
```bash
git branch
```
また、次のように、新しく作ったブランチが指定されていることを確認してください。(* がブランチ名の前についていれば指定されています。)
```
* dev-newMessage
  master
```
それでは、過去の状態から新しい変更を加えてみましょう。その際、次の条件を満たすような変更を加えてください。
- masterブランチ上で変更記録を行った変更と違う変更を加える。(変更の競合をさせます)
- masterブランチ上で作成していないファイルを作成する。

条件を満たした変更が行えたら、コミットしてください。


現在の状態を振り返りましょう。今までの時点で、masterブランチとその途中から派生する新しいブランチの2種類のブランチで進めてきました。<br>
しかし、このまま並走し続けるわけにも行かないので、どこかで統合する必要があります。ここで出てくるのがmerge(マージ)です。今回は、masterブランチに新しく作ったブランチの変更内容をマージすることにしましょう。<br>
今までのイメージと、今回のマージで目指すのは以下のような図です。<br>
<img src="https://raw.githubusercontent.com/Yu-HaruWolf/git-workshop-note/main/images/git_current_image_diagram.png" alt="merge image" height="300px"><br>
それでは早速やっていきましょう。まずは、まとめる先のブランチに切り替える必要があります。ブランチの切り替えは以下のコマンドでできます。
```bash
git switch master
```
これでmasterブランチでの作業に戻ってくることができました。ここに新しいブランチで作業していた内容をマージしましょう。マージは以下のコマンドでできます。
```bash
git merge dev-newMessage
```
これできれいにくっつく、とは行きませんね。gitがマージする上で困るようにファイルを編集しているので、恐らく「CONFLICT」が起こっているのではないでしょうか。(もし起こっていない場合は、gitがうまくマージしてくれたか、そもそもうまくマージできていないかもしれません。ファイルの内容を確認してみて、どのような結果になっているか確認してください。)<br>
ただ、全ての変更内容がうまくマージできなかったわけではありません。新しく作っていたファイルはmasterブランチの作業内容に追加されているのが確認できると思います。開発者が確認するべきなのは、CONFLICTが起こった箇所です。実際にファイルの中身を見ていきましょう。
```
<<<<<<< HEAD
print("Hello, World!")
=======
print("Hello, Git!")
>>>>>>> dev-newMessage
```
ファイルの中身がこのようになっているところが、CONFLICT(競合)が起こった箇所です。
イコールで競合した変更内容が区切られており、上下にはgitによる注釈が加えられています。上のHEADが現在の作業中のブランチ、下がマージ元のブランチの変更内容です。開発者はここをいい感じに直してあげればOKです。いい感じと言われるとアバウトですが、その時一番正しいと考えられる状態に直してあげると良いでしょう。<br>
直し終わり、gitによって作成された注釈等も削除し、記録して良い状態になったら、保存をして、いつものようにコミットを行います。マージすること自体も変更記録として記録をします。

ここまで行ったことを`git log`で確認しましょう。ただ、分岐が発生したことで今までのままだと見にくいので、新たなオプションを加えます。
```bash
git log --graph
```
このオプションを加えることで、今までのログに加え、どこでブランチを作成し、どこでマージされたのかが見やすくなります。<br>

ここまではGitのバージョン管理について扱ってきました。gitのバージョン管理の基本的なところはこれで扱えるようになりました。ここまでのことを軽くおさらいしましょう。
- Gitリポジトリの作成(git init)
- Gitに変更内容を記録(git commit)
- 過去の内容に遡る(git switch --detach)
- 新たなブランチを作成する(git switch --create)
- 2つのブランチを1つのブランチにまとめる(git merge)

この後は共同開発で使っていくための機能について、説明します。ここからはGitHubを使用するので、まだGitHubのアカウントをお持ちでない方はここで作成しましょう。一旦一休みしましょう。🍵